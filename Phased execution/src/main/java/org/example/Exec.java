package org.example;

/** --- Задача ---
  *
  * Выполнить многопоточное приложение с 2 параметрами для нижеследующей задачи.
  * Работники (количество работников задано параметром) собирают яблоки в ящики (количество ящиков задано параметром).
  * Дополнительный работник - мастер координирует работу, каждый работник сообщает ему о том, что собрал очередной ящик.
  * Когда каждый работник соберет ящик, то он ждет пока остальные работники тоже соберут по одному ящику, по сигналу
  * мастера он продолжает работу. Работа заканчивается, когда все ящики будут собраны.
  * Не используйте любые задержки для потоков после начала их работы в виде методов sleep, yield или wait c параметром.
  * Неработающий поток находится в состоянии ожидания сигнала от другого потока и продолжает работу только когда такой
  * сигнал получен. Выводить идентификатор работника вместе с номером ящика для каждого потока.
  *
  * --- Описание, 5 модулей ---
  *
  * - модуль Demonstration - содержит интерфейс Demonstration в котором объявлены два метода, calculate_parameters()
  *   для проверки и расчета параметров и start_gather() для выполнения предполагаемой работы.
  *
  * - модуль CyclicBarrierDemonstration - содержит класс CyclicBarrierDemonstration предназначеный для демонстрации работы
  *   многопоточного приложения с поэтапным выполнением действий с использование библиотечного класса CyclicBarrier,
  *   в методе calculate_parameters() производится проверка вводимых параметров, необдходимых для работы приложения, и
  *   их расчет, а именно количество этапов, количество работников и количество коробок, в методе start_gather()
  *   организована работа потоков с барьером, так же в нем предусмотрена корректная работа в ситуации, когда кол-во
  *   ящиков не делится без остатка на кол-во работников, класс MyThread описывает действия потока при выполнении,
  *   ожидание других потоков происходит путем вызова метода await(), класс BarAction описывает действия потока при
  *   выполнении очередного этапа.
  *
  * - модуль PhaserDemostration - содержит класс PhaserDemostration предназначеный для демонстрации работы
  *   многопоточного приложения с поэтапным выполнением действий с использование библиотечного класса Phaser,
  *   в методе calculate_parameters() производится проверка вводимых параметров, необдходимых для работы приложения, и
  *   их расчет, а именно количество этапов, количество работников и количество коробок, в методе start_gather()
  *   организована работа потоков с помощью объекта типа Phaser, класс MyPhaser предназначен для контроля работы потоков,
  *   класс MyThr описывает действия потока при выполнении, ожидание других потоков происходит путем вызова метода
  *   arriveAndAwaitAdvance().
  *
  * - модуль CyclicBarrierExecutorsDemonstration - содержит класс CyclicBarrierExecutorsDemonstration предназначеный
  *   для демонстрации работы многопоточного приложения с поэтапным выполнением действий с использование библиотечного
  *   класса CyclicBarrier и ExecutorService. В методе calculate_parameters() производится проверка вводимых параметров,
  *   необдходимых для работы приложения, и их расчет, а именно количество этапов, количество работников и количество
  *   коробок, в методе start_gather() организована работа потоков с барьером, так же в нем предусмотрена корректная
  *   работа в ситуации, когда кол-во ящиков не делится без остатка на кол-во работников, класс Box описывает
  *   действия потока при выполнении, ожидание других потоков происходит путем вызова метода await(), класс BarrierAction
  *   описывает действия потока при выполнении очередного этапа. За счет использования класса ExecutorService и его
  *   методов появляется возможность создать пул потоков, соответсвующий кол-ву работников и переиспользовать эти потоки
  *   на каждом этапе, а не создапвать новые.
  *
  * - модуль Exec - содержит класс Exec (Execution) с методом main в котором от пользователя требуется ввести с консоли
  *   параметры, на основе которых происходит дальнейшая работа программы, создаются объекты описанных классов и
  *   демонстрируется работа каждого из них по очередности.
  *
  * --- Резюме ---
  *   Использование класса CyclicBarrier позволяет более точно контролировать кол-во потоков выполнения, в соответсвии
  *   с условиями задачи, но при организации очередного этапа выполнения создаются новые потоки, если работа производится
  *   с одиними и теми же ресурсами, то предоставление доступа к ним потребует большего количества кода.
  *   Использование класса Phaser проще чем CyclicBarrier, на каждом новом этапе созданные потоки продолжают свою работу,
  *   нет возмоности точно контрлировать количество потоков, в каждой фазе их количесвто фиксировано к начальному значению.
  *   Применение класса ExecutorService совместно с CyclicBarrier позволяет более точно добиться поставленной задачи.
  *   Возможно точно указать кол-во потоков на выполнение в каждом этапе, к тому же потоки на каждом этапе переиспользуются,
  *   а не создаются новые.
  *
 **/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Exec {
    public static void main(String[] args) {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int amount_of_workers = 0;
        int amount_of_boxes = 0;
        int amount_of_phases = 0;

        try {
            System.out.print("\nEnter amount of workers: ");
            amount_of_workers = Integer.parseInt(reader.readLine());
            System.out.print("Enter amount of boxes: ");
            amount_of_boxes = Integer.parseInt(reader.readLine());
        } catch (IOException | NumberFormatException e) {
            System.out.println("Input data");
            //e.printStackTrace();
        }

        System.out.println("\n***************Parametrs***************");
        System.out.println("Amount of workers - " + amount_of_workers);
        System.out.println("Amount of boxes - " + amount_of_boxes);

        try {
            amount_of_phases = amount_of_boxes / amount_of_workers;
            System.out.println("Amount of phases - " + amount_of_phases);
            System.out.println("**************************************");
        } catch (ArithmeticException e) {
            System.out.println("Data was entered incorrectly");
            //e.printStackTrace();
        }

        if (amount_of_phases >= 0) {
            Demonstration CBD = new CyclicBarrierDemonstration(amount_of_workers, amount_of_boxes);
            CBD.start_gather();

            Demonstration PD = new PhaserDemostration(amount_of_workers, amount_of_boxes);
            PD.start_gather();

            Demonstration CBED = new CyclicBarrierExecutorsDemonstration(amount_of_workers, amount_of_boxes);
            CBED.start_gather();
        }
    }
}